Более точное описание реализаций см. в файле .\VinKekFish\GeneralOfDetails.md
Здесь описание примерное

# Незаконченные работы
Тест на длинну гаммы в режиме Overwrite
Проверить в тесте на то, что 1253539379 даёт длительный прирост (без приращения, с умножением).
Проверить по списку типовых ошибок

Сделать статистические тесты (см. в конце)

Сгенерировать таблицы transpose\* и просто задать их. Ну или алгоритм сделать.

Сделать реализации и протестировать их


# Алгоритм VinKekFish

Алгоритм имеет криптографическое состояние и Tweak (настройка для ThreeFish).
Построен аналогично keccak на основе конструкции Губка (Sponge) и на основе криптографических преобразований keccak и ThreeFish.

Все известные алгоритмы берутся полнораундовыми, так как неполнораундовые с большей вероятностью внесут какие-либо паразитные связи между битами.

# Полный шаг губки
Перед первым шагом губки (или дуплекса) следует первичная инициализация
Она выполняется для губки (или дуплекса) один раз за всё время её работы. В дальнейшем названия "губка" и "дуплекс" считаются эквивалентными (т.к. работают в данном алгоритме одинаково).

После первичной инициализации следуют шаги шифрования.
Для каждого шага следует:
1. Вычисление нового Tweak для следующего шага
2. Непосредственный ввод данных, изменение Tweak относительно вводимых данных, режима ввода и логического режима шифрования
3. Предварительное преобразование
	3.1. Перестановка для распределения впитанных данных
	3.2. Поблочное шифрование TreeFish
	3.3. Перестановка
4. Основной шаг алгоритма (криптографические раунды)
5. Заключительное преобразование:
	5.1. Заключительная рандомизация, состоящая в поблочном keccak и перестановке. Повторяется некоторое количество раз.
6. Перестановка для объединения данных для вывода (объединена с заключительным преобразованием)
7. Вывод данных

В случае необходимости, для повышения защищённости вывода от ошибок VinKekFish, вывод данных может быть пропущен через губку keccak.
В таком случае, губка может быть инициализирована полным ключом шифрования для VinKekFish, а затем однократным выводом с первого раунда VinKekFish (также, см. ниже).

# Использование губки
Примерное использование губки.

1. Ввод ключа (или открытого вектора инициализации)
2. Ввод открытого вектора инициализации (или ключа)
3. Ввод данных, вывод гаммы
4. Вывод гаммы и/или хеша

## Например, гаммирование с обратной связью по открытому тексту.

1. Ввод ключа, счётчик режимов 1. Инициализация Tweak любым значением. Шаг губки.
2. Ввод ОВИ, счётчик режимов 128. Шаг губки.
3. Вывод блока гаммы (и применение её к открытому тексту).
4. Ввод открытого текста. Счётчик режимов 0. Шаг губки.
5. Вывод блока гаммы
6. И так далее

Реальные схемы шифрования см. в файлах рядом: (пока таких файлов нет)

# Размер криптографического состояния

Размер состояния K*25600,
где K - нечётное натуральное число (1 или более; 1, 3, 5, 7 и т.д. до 19 включительно).
Для K > 11, при перемешивании блоков keccak за один шаг перемешивания невозможно перемешать блоки так, чтобы хотя бы один байт каждого блока был бы представлен в каждом новом блоке. Это может повлечь некоторое снижение стойкости алгоритма при том же количестве раундов (а может и не повлечь).
В связи с этим, рекомендуется использовать алгоритм при K = 1, 3, 5, 7, 9, 11.

Нечётность числа следует из того, что тогда общее количество блоков не делится на два. Для количества блоков 25 следует, что threefish применяется к парам (0;12), (12,24), (13,0).
Если бы блоков было чётное количество, то threefish применялся бы один раз в паре (0;12), а один раз к паре (12; 0). То есть было бы два зависимых между собой криптографических преобразования, которые не были бы зависимы от других блоков, что упрощало бы криптоанализ и уменьшало бы диффузию между блоками.

При нечётном K при преобразовании 0-ого блока ключ берётся из 12-ого блока. Но ключ из 0-ого блока берётся для преобразования 13-ого блока. То есть при многократном преобразовании, блоки будут сами собой перемешивать данные даже без таблиц перестановок и нет ярко выраженной зависимости между двумя блоками. Данные не будут зацикливаться только на одной паре блоков.

Для K > 19 индексы не умещаются в 2-хбайтовых числах, а перемешивание становится всё хуже, поэтому алгоритм использовать не целесообразно и он не разрабатывается для таких значений.

# Размер Tweak
Как определено в ThreeFish, размер Tweak составляет 16-ть байтов.

# Первичная инициализация

Первичная инициализация проходит один раз перед началом использования губки.
Дополнительная инициализация ключами или вектором инициализации происходит в шаге алгоритма (подаваемыми на вход губки или в начальный tweak)


## Tweak

Tweak инициализируется нулями либо вектором инициализации. В том числе, инициализация может происходить номером шифруемого блока при древовидном алгоритме шифрования.
Nonce лучше инициализировать непосредственно губку, чтобы обеспечить большую радномизацию. То есть Nonce вводить в губку для впитывания, а не в tweak.

Положено, что Tweak известен злоумышленнику. Если он не известен, то считается, что злоумышленник может его вычислить (нет никаких доказательств, что tweak нельзя вычислить).
Так что в Tweak не должно быть конфиденциальных значений, которые не должны быть раскрыты (в целом, это не запрещает инициализировать tweak дополнительным ключевым значением, которое более нигде не используется). Хотя раскрыть хорошо проинициализированный tweak, скорее всего, злоумышленнику будет сложно.


## Криптографическое состояние

### Сложная инициализация

Криптографическое состояние разделяется на строки по 16-ть байтов.
Таблица заполняющих чисел fillTable
0  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61

Далее, для i-ой строки каждого столбца происходит заполнение байта значением (i+1)\*(fillTable[N]), где N есть шаг алгоритма для данного столбца (начиная с нуля).
То есть для нулевой строки, копируется содержание fillTable, для первой строки - содержание fillTable копируется с умножением на два.

Например, для состояния из 32-х байтов состояние будет инициализировано следующими значениями
003 007 010 013 017 019 023 029 031 037 041 043 047 053 059 061 006 014 020 026 034 038 046 058 062 074 082 086 094 106 118 122

Таким образом обеспечивается заполнение всего начального состояния уникальными 16-ти байтовыми значениями для большей начальной рандомизации. Так как алгоритм поблочный, это поможет блокам сильнее отличаться друг от друга на первом шаге.

### Инициализация нулями (простая инициализация)
Вместо указанного выше алгоритма, допускается инициализировать начальное состояние нулями.

В реализациях данного проекта всегда принята простая инициализация.

# Вычисление нового Tweak для следующего шага

Перед непосредственным вводом данных осуществляется приращение младшего 8-мибайтового слова на значение 1253539379 (это простое число, дано в десятичной системе исчисления - в принципе, сюда можно взять любое другое число, лучше - простое). Младшее слово в массиве - первое (младший байт по младшему адресу).
Старшее 8-мибайтовое слово не изменяется (к нему осуществляется приращение при вводе данных). В том числе, бит переноса из младшего слова в старшее не переносится.

# Непосредственный ввод данных

Ввод данных осуществляется по блокам в 4096 битов (512-ть байтов).
Размер (в байтах) вводимого блока данных обозначим за r. r имеет размер 2 байта. r вводится в tweak и во внутреннее состояние. Ещё 1 байт (режим ввода) вводится во внутреннее состояние счётчика режимов.
Также в tweak могут вводится режимы работы губки (губка или overwrite).

Для K = 19 размер ввода ограничен 512*K = 512*19 = 9728
Два старших бита размера всегда должны быть пусты, так как туда записываются режимы overwrite (при таком размере это ещё обеспечивается).

## Подробное описание ввода размера и режима

После вычисления нового Tweak (см. выше), к старшему 8-мибайтному слову Tweak добавляется (арифметическим сложением) 2 байта размера вводимого блока (то есть добавляется число r).
Если ввод осуществляется в режиме overwrite, то к старшему байту старшего 8-мибайтового слова добавляется ещё 1 (то есть добавляется 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову).
В режиме губки ничего не добавляется (только размер вводимого блока). Режим padding в режиме overwrite в tweak никак не обозначается.
Кроме этого, в любом из режимов, к 3-ему (нумерация, начиная с 1) по старшинству байту старшего 8-мибайтового слова добавляется значение счётчика режимов. Например, если счётчик режимов 3, то добавляется 0x0000_0300_0000_0000 (regime << 40).

Ввод в криптографическое состояние может осуществляться с операцией побайтового xor (в режиме губки). Первые байты (младшие байты) идут по младшим адресам. Xor осуществляется непосредственно с первыми 512-тью байтами, точнее, сначала идёт два байта количества вводимой информации, потом один байт счётчика режима, а потом ввод (то есть не от 0 до 512 не включая, а от 3 до 515 не включая).
Также ввод может осуществляться простой перезаписью байтов (режим overwrite).

padding отсутствует, т.к. в tweak осуществляется ввод размера вводимого блока.
В режиме overwrite padding состоит в следующем.
Перезаписывается внешнее криптографическое состояние вводимым массивом байтов.
Перезапись каждого оставшегося байта (из внешнего состояния) осуществляется теми же значениями, как в начале использования губки.
Например, если осуществлён ввод числа 01 08 03, то первые 16-ть байтов будут следующими
001 008 003 013 017 019 023 029 031 037 041 043 047 053 059 061
Однако, это только если выбран сложный вариант инициализации.
Если выбран простой способ инициализации - то байты просто перезаписываются нулями.
001 008 003 000 000 000 000 000 000 000 000 000 000 000 000 000

(В реализациях данного проекта всегда принята простая инициализация)


Первые два байта криптографического состояния получают xor (всегда именно xor вне зависимости от режима) с числом r (количеством вводимых байтов), и ещё следующий байт получает xor со счётчиком режимов.
Старший бит числа r (количества вводимых байтов) устанавливается в 1, если используется режим overwrite. Если overwrite используется без padding (то есть блок ввода не перезаписывается нулями после конца данных), то второй по старшинству бит также устанавливается.
Счётчик режимов может показывать, что именно происходит. Например, счётчик 1 может показать, что вводится вектор инициализации, счётчик 2 - что вводится ключ, счётчик 0 - что вводятся данные и т.п.
Режим overwrite в данном счётчике никак не обозначается.

Допускается обозначать другие особенности ввода изменением неиспользуемых битов числа r или изменением счётчика режимов (если это не вводит неоднозначности при таком использовании).

Счётчик режимов может работать и в любых иных режимах или игнорироваться (быть нулём, то есть ни на что не влиять).

Пример алгоритма назначения счётчика режимов. Счётчик режимов выбирается следующим
1, 2, 3, 4 ... - для блоков ключей
128, 129, 130, 131 - для блоков открытых векторов инициализации
0 - для остальных вводимых данных.


## Перестановка для распределения впитывания
Затем выполняется перестановка с помощью таблицы transpose128_3200 (см. ниже). То есть перед раундами шифрования идёт однократная перестановка transpose128_3200.
После этого выполняется однократная поблочная операция treefish с transpose128.
После этого начинаются раунды шифрования (основной шаг).

Распределение впитывания идёт вне зависимости от того, впитано ли что-либо или нет.
Tweak в этом распределении никак не изменяется (это твик, входящий на этот шаг и использующийся без изменений в первом раунде)

Распределение позволяет
1. Избежать значительного влияния злоумышленника (своим вводом) на какой-то конкретный блок шифрования, одновременно не выдавая слишком много байтов при выводе
2. Развязать keccak заключительной рандомизации с первым keccak раундов через применение treefish

## Если ввода не было
Если ввод был нулевого размера, то, из вышеописанного алгоритма следует следующее.

### В режиме губки
Если ввода не было, к tweak добавляется перерасчёт при начале шага +1253539379 к младшему слову.
В состояние вводится счётчик режима (если он не нулевой).
"Перестановка для распределения впитывания" выполняется.

### В режиме overwrite
Если ввода не было, к tweak идёт приращение 0x0100_0000_0000_0000 к старшему 8-мибайтовому слову (и +1253539379 к младшему 8-мибайтовому слову).
Все 512-ть первых байтов криптографического состояния перезаписываются нулями.
"Перестановка для распределения впитывания" выполняется.


### Ввод данных на следующий шаг не должен зависеть от выхода данных с предыдущего шага

Запрещено осуществлять ввод данных, которые зависят от полученных от губки данных с этого же шага.

Это важно для того, чтобы злоумышленник не мог воспользоваться выходом дуплекса для того, чтобы его атаковать.
См. стр. 4 "1.3 Our Contribution" "Full-State Keyed Duplex With Built-In Multi-User Support" https://keccak.team/files/FSKD.pdf.


### Ввод ключа

Ввод ключевой информации делается с помощью перезаписи, то есть в режиме overwrite. Это связано с тем, что перезапись информации более безопасна с точки зрения ПЭМИН, чем xor.

Ввод ключа до открытого вектора инициализации поставляет злоумышленнику данные для анализа данного ключа каждый раз при вводе. Однако, эти данные одни и те же, то есть прибавляют статистику только если оборудование для считывания неточное. В то же время, если оборудование точное - то оно считает ключ полностью либо считает множество данных, являющихся суммой обрабатываемых сигналов в каждый момент времени. За счёт этого, может быть получено довольно много данных.
На следующих шагах (при введении ОВИ) эти данные будут уже преобразовываться с различными данными.
Кроме этого, ввод открытого вектора инициализации возможен в режиме overwrite, что поможет выполнить необратимую операцию и создать неопределённость в отношении ключа для криптоаналитика.


Ввод ключа после открытого вектора инициализации поставляет злоумышленнику данные для анализа данного ключа, причём каждый раз разные. Однако, в обоих случаях (ввод перед/после), на втором этапе данные будут различны.
В целом, предпочтительнее вводить ОВИ (открытый вектор инициализации) ранее ключа. Так, по крайней мере, не будет ясно видной повторяющейся радиосигнатуры при начале шифрования одним и тем же ключом.


Ввод ключа на первом шаге (до любых преобразований) допускается путём инициализации криптографического состояния этим ключом (то есть простой записи ключа во внутрь состояния или дозаписи с xor), причём размер ключа в таком случае ограничивается лишь внутренним состоянием.
Допускается также одновременный ввод ключа и вектора инициализации тем же путём. Это аналогично инициализации "keyed duplex".
В таком случае разработчик должен обеспечить недвусмысленное отделение ключа от вектора инициализации, и всего этого от последующих данных. Например, путём фиксирования размера ключа и вектора инициализации. Необходимо также исключить одновременную запись (из разных потоков) в одну линию кеша при инициализации (если инициализацию выполняют несколько потоков), иначе одновременная запись в одну линию кеша повлечёт за собой инвалидацию кешей разных процессорных ядер.

После ввода ключевой информации и ОВИ, рекомендуется всегда делать холостой шаг алгоритма (без ввода данных), чтобы дополнительно отбить ключ. При этом, чтобы затруднить восстановление ключа, холостой шаг может быть сделан в режиме overwrite, то есть с перезаписью части данных нулями (это операция является необратимой и создаёт неопределённость в отношении ключа).


# Вывод данных

## Перестановка для объединения данных для вывода
После выполнения основного шага алгоритма, выполняется заключительное преобразование (заключительная рандомизация), см. ниже "Основной шаг алгоритма".

## Сам вывод
Если нужен вывод, то берутся первые 512-ть байтов состояния (младший байт по младшему адресу).
Перестановка выполняется вне зависимости от того, нужен вывод или нет.


# Основной шаг алгоритма

Основной шаг алгоритма состоит из применения 64-х раундов, состоящих из

0. Вычисление tweakVal
1. Поблочное преобразование keccak (точнее keccak-f)
2. Перестановка P1
3. Поблочное преобразование threeFish
4. Перестановка P2
5. Поблочное преобразование keccak
6. Перестановка P3
7. Поблочное преобразование threeFish (с довычисленным tweakVal)
8. Перестановка P4.

После последнего раунда производится заключительное преобразование - заключительная рандомизация. Применяется поблочная функция keccak-f (аналогично пунктам 1 и 5).
То есть идут следующие преобразования (keccak-f + transpose200)\*(keccak-f + transpose200_8)\*(keccak-f + transpose200)\*(keccak-f + transpose200_8)

Допускается использовать (keccak-f + transpose200)\*(keccak-f + transpose200_8) - то есть 2 шага заключительной рандомизации вместо 4-х.
Для K > 11, в связи с худшим перемешиванием, нужно добавить ещё 2 шага (то есть в сумме, 6 шагов, а не 4).


Для P1 используется rnd
Для P2 используется rnd
P3 - transpose200
P4 - transpose128

Для таблиц перестановок rnd рекомендуется первые 8-мь или 4-ре раунда (и, обязательно, первый раунд), использовать P1=transpose200_8 и P2=transpose128. В реализации допускается и отсутствие использования случайных перестановок.

Один или оба из P1 или P2 может быть зависим от дополнительного независимого ключа. Предлагается, P1 как зависимый от независимого ключа. Независимый ключ - это ключ, который развязан с основным ключом с помощью алгоритма не меньшей стойкости, чем заданный, либо получен полностью независимо (то есть из количества энтропии не меньшего, чем стойкость основного ключа). Независимость ключа следует из того, что перестановки легче перехватывать по побочным каналам, чем простые ключевые вычисления.



Довычисление tweakVal происходит следующим образом.
Работа ведётся с младшим 8-мибайтовым словом tweak (старшее слово не затрагивается, в том числе, бит переноса с младшего слова на старшее не переносится).
Старшее 4-хбайтовое слово tweak складывается с номером раунда, домноженным на 2 (tweak не изменяется, запись производится в tweakVal; tweak по прошествии раунда остаётся таким же, каким был до начала раунда).

Для каждого блока всё значение (8-мибайтовое младшее слово) складывается с номером блока (начиная с нуля). То есть для нулевого блока используется TweakVal, для первого блока: TweakVal + 1.

Таким образом, на каждый раунд и для каждого блока TweakVal разный.

На второе преобразование threeFish (пункт №7) дополнительно старшее 4-хбайтовое слово tweak приращается на единицу (tweakVal[0] += 0x1_0000_0000;).

## Поблочное преобразование threefish

Для блока i выполняется преобразование с ключом из блока j. Причём блок j берётся из первичного состояния. То есть блоки i и j - это блоки, значения которых берутся на момент начала поблочных операций.

Пусть N - количество блоков ThreeFish, которые умещаются во внутреннем состоянии.
Тогда j вычисляется как (i + N/2) mod N

# Защита после вывода

VinKekFish не проверен криптоаналитиками, поэтому, его стойкость находится под сомнением.
Чтобы уменьшить риски, можно защитить вывод. Однако это не обязательно.

1. Если используется генерация ключевой информации или ОВИ из основного ОВИ и основного ключа.
1.1. Для генерации 512 битных ключей и ОВИ

Вывод VinKekFish делится на блоки по 64-ре байта и пропускается через один keccak duplex. Дуплекс каждый шаг выдаёт 64-ре байта вывода.
Взаимозависимость таких ключей - 512 битов (VinKekFish эту стойкость не увеличивает).

Для усиления защиты, в keccak duplex может быть заранее введён дополнительный ключ. Вместо дополнительного ключа может быть использован следующий алгоритм:
a.1) Ввести в keccak поблочно весь основной ключ (после каждого блока выполнять преобразование keccak)
a.2) Выполнить преобразование VinKekFish (включая ввод основного ключа в VinKekFish)
a.3) Ввести в keccak поблочно выход от преобразования VinKekFish (после каждого блока выполнять преобразование keccak)
a.4) После этого выполнить преобразование VinKekFish и преобразование keccak без ввода данных.
Считать VinKekFish и keccak проинициализированными


1.2. Для генерации ключей и ОВИ, стойкостью 1024 бита. Полагаемся на предположение, что VinKekFish обеспечивает такую стойкость совместно с защитой.

Вывод VinKekFish делится на блоки по 128 байтов. Вводятся в keccak duplex с помощью xor с состоянием алгоритма (с rate, увеличенным до 128 байтов).
Дуплекс каждый шаг выдаёт по 512 битов (64 байта). Два блока VinKekFish по 128 байтов дадут после дуплекса два блока по 64 байта. В сумме получим 128 байтный блок.

2. Генерация гаммы, стойкостью 512 битов.

Аналогично 1.1. Вывод VinKekFish делится на блоки по 64-ре байта и пропускается через один keccak duplex. Дуплекс каждый шаг выдаёт 64-ре байта вывода.

3. Генерация гаммы, стойкостью 1024 бита. Полагаемся на предположение, что VinKekFish обеспечивает такую стойкость совместно с защитой.

3.1.
Аналогично 1.2. Вывод VinKekFish делится на блоки по 128 байтов. Вводятся в keccak duplex с помощью xor с состоянием алгоритма (с rate, увеличенным до 128 байтов).
Дуплекс каждый шаг выдаёт по 512 битов (64 байта). Два блока VinKekFish по 128 байтов дадут после дуплекса два блока по 64 байта. В сумме получим 128 байтный блок.

Как более медленный вариант, можно предложить вводить в keccak duplex большее количество блоков или уменьшать rate самого VinKekFish.


4. Универсальный ослабленный вариант. Каждый вывод VinKekFish полностью вводится в keccak duplex по 64-ре байта за ввод. На один полный вывод VinKekFish приходится 64 байта вывода. Эти 64 байта, правда, могут быть независимы друг от друга только на 1024 бита стойкости из-за того, что они вводятся в один и тот же keccak. Но каждый блок будет развязан.
Очень медленный вариант.
4.1. Как более быстрый вариант вместо ввода полного вывода VinKekFish, может быть осуществлён ввод только 1024 битов информации.


5. Аналогично 1.1. При этом формируется отдельная гамма с помощью одного VinKekFish без защиты keccak, и отдельная гамма с помощью другого VinKekFish с защитой keccak. Ключ для keccak вводится основной, как и в 1.1.
Чтобы два состояния VinKekFish отличались друг от друга может быть использована разная начальная инициализация либо дополнительная инициализации первого VinKekFish от блока keccak.


В моих реализациях VinKekFish ни одна из этих защит использована не будет (возможно, будет использован 5-ый вариант).


## Рекомендация для дублирующих алгоритмов
С точки зрения оптимальной защиты, можно создать один (или два) keccak duplex и, после первого шага дуплекса VinKekFish, проинициализировать его вводом из VinKekFish (200 байтов ввода, остальные байты выбрасываем либо ещё 200 берём для ОВИ во второй дуплекс). Далее keccak duplex может работать самостоятельно на создание ключей и ОВИ для дублирующего защитного шифрования. А VinKekFish будет использоваться независимо.
Разумеется, здесь есть доверие VinKekFish в плане генерации ключевой информации для дублирующего duplex.


# Таблицы перестановок
// transpose200_8_inv - не используется
transpose200_8
transpose200
transpose128

Реализация алгоритма получения таблиц: VinKekFishBase_etalonK1.GenTransposeTable
Таблицы перестановок расположены в файлах ./tables/transpose-128.txt ./tables/transpose-200.txt ./tables/transpose-200_8.txt

Алгоритм выполнения перестановок в случае таблиц transpose200 и transpose128 состоит в том, чтобы транспонировать матрицу с размером строки 200 и 128 байтов. Под матрицей понимается массив криптографического состояния, который понимается как матрица, сохранённая по строкам подряд в массив.

Тест для проверки верности перестановки:
Если в исходном массиве первые байты были 0, 1, 2, 3 и т.п., то после перестановки transpose200 первые байты должны быть 0, 200, 400, 600, ..., 3000, 1 и т.п.
Если в исходном массиве первые байты были 0, 1, 2, 3 и т.п., то после перестановки transpose128 первые байты должны быть 0, 128, 256, 384, ..., 3072, 1 и т.п.

transpose200_8
Таблица выполняется немного по-другому. При достижении индексом максимума (3200), смещение индекса идёт не на 1, а на 8. То есть начинаем новый цикл заполнения с числа 8, вместо числа 1.
При этом, при достижении начальным индексом значения 200 или более, из него вычитается 200, и добавляется 1.

transpose200_8_inv
Эта таблица является обратной операцией таблице transpose200_8.
Для размера 3200 - это таблица transpose400_16
Для размера 3200\*K  - это таблица transpose(400\*K)_(16\*K)


Таблицы перестановок выводятся в файл в тесте
\VinKekFish_cryptoDev\permutationsTest\old\VinKekFish\GenTablesTest.cs
Двойное транспонирование не ведёт к той же самой расстановке, что и до двойного транспонирования (см. файл \VinKekFish_cryptoDev\permutationsTest\bin\Debug\results\transpose-200-200.txt). То есть результат после transpose200\*transpose200 будет отличным от исходных данных.

# Количество раундов

Даже при количестве раундов 0 алгоритм должен давать хорошую стойкость.
Для упрощения, минимальное количество раундов может увеличиваться на 1 на каждую ступень K (K = 3 => +1, K = 5 => +2, K = 7 => +3, K = 9 => +4, K = 11 => +5). В целом, количество раундов, видимо, может увеличиваться как двоичный логарифм размера криптографического состояния.

Нормальное количество раундов может увеличиваться на 8 на каждую ступень K.


# Прикидки стойкости алгоритма

Суммарная длина криптографического состояния 25600 битов.
Скорость - 4096 битов.
Ёмкость, 25600 - 4096 = 21504

Примем за оценку стойкости следующую формулу. Вероятность вскрытия алгоритма равна
P = N^2 / 2^c

Где c - ёмкость, N - количество блоков, доступных для злоумышленника (для вычисления или сверки).

Считая, что P зависит от длины ключа и равна 2^-k можем считать
2^-k = N^2 / 2^c

Длина гаммы в блоках, таким образом, равна
N = 2^((c-k)/2)

Для стойкости 8192 бита
2^(21504-8192)/2=2^(21504-8192)/2=2^6656

Таким образом, длина гаммы (с вероятностью раскрытия не более 2^-k) обеспечена не менее, чем 2^4096 блоков или 2^4105 байтов.


Оценочная неравномерность диффузии, 2^-20 (одна миллионная) на 4 преобразования с перестановками, то есть на раунд. (исходя из VinKekFish_cryptoDev\permutationsTest\matrix\r-threefish-transpose128-04.txt)

Исходя из этого можем сделать предположение, что 1 раунд не может быть использован для шифрования не более 1 мегабайта данных (в том смысле, что выводится более 1 Мб известного злоумышленнику выхода). 1 раунд на диффузию + рандомизация - это минимальная защита. Значит, далее берём 1 раунд непосредственно на объём данных.
Получаем, что для 2^20\*R байтов можно зашифровать с помощью R+1 раундов.
Таким образом, ограничение на шифрование на одном ключе 4-х раундовым шифром равно 2^20\*3=2^60 байтов, то есть порядка 1,15e18, то есть порядка 1 Петабайта информации. Разумеется, ключи, желательно, выбирать одноразовыми.


Коллизии. Ожидаемая нагрузка для генерации коллизии равна 2^(c+3)/2 ( https://keccak.team/files/SpongeFunctions.pdf )
2^(21504+3) / 2 = 2^10753,5 ~= 2^10753
С запасом в 4096 битов получаем выше вычисленные 2^6656


# Тесты для проверок
Сжимаемость 7-zip
Частотный тест
	Определение количества нулей и единиц в блоках определённой длинны
	Максимальное отношение нулей и единиц и его распределение от блока к блоку
	Можно смотреть дисбаланс (+1 и -1 вместо 1 и 0; отношение дисбаланса к общему количеству должно уменьшаться при увеличении длины гаммы)
		https://habr.com/ru/company/securitycode/blog/237695/ Частотный побитовый тест
			Sobs = модуль дисбаланса делить на квадратный корень из количества битов (|S|/sqrt(n))
			erfc - функция эрфик для биномиального распределения
				(дополнительная функция ошибок: https://ru.wikipedia.org/wiki/Функция_ошибок )
			P = erfc(Sobs/sqrt(2)) должно быть более, чем 0,01.
		Тест на одинаковые идущие подряд биты (там же)
			Кстати, тест на знакоперемены можно ведь делать и к знакопеременам (правда, там будут худшие результаты)
		Спектральный тест (там же)
	Определение количества значений байтов
		Отношение максимума встреченных байтов к минимуму
		Распределение таких отношений (график)

Длина гаммы в режиме Overwrite с нулевым Tweak


\VinKekFish\main_tests\Задачи и другое\Криптография\Размышления\VinKekFish\РазмыленияОТестах\МинимальноеКоличествоПредставленныхЧисел.txt


# Почему 4096 битов?

Стойкость схем шифрования, желательно, обеспечивать не менее, чем на жизнь человека и его детей. При продолжительности 70-ть лет, это 70+70=140 лет.
Кроме этого, шифр, сам по себе, нужно использовать какое-то время, то есть, допустим, ещё 60 лет. И того - 200 лет стойкости.

Минимальный перевод стойкости в годы: 1 бит за два года.
Более реалистичный, с учётом развития математики и т.п.: 1 бит за 1 год.
Экстремальный: 2 бита за год.

При минимальном переводе, 200 лет стойкости, это 100 битов. При этом, считаем, что в 80-ом году стойким можно было считать шифр в 80-т битов.
Таким образом, базовая минимальная оценка на 2020-ый год: 80 + 40/2 + 100 = 200 битов

"Нормальный" перевод: 80 + 40 + 200 = 320 битов

Экстремальный перевод: 80 + 40*2 + 200*2 = 560 битов

Коэффициенты запаса.
мин  макс (разы)
1,5  2      на уязвимости в шифре.
1,0  2      на уязвимости в схеме.
2    2      на коллизии (считаем, что они обязательно будут).
2    3      на квантовые компьютеры
1,5  2      на уязвимости в самом ключе
1	 2		запас на ПЭМИН (на случай, если противник считывает часть информации, но далеко не всю)

9    96     суммарный коэффициент (произведение коэффициентов)

320*9 = 2880 битов
То есть имеем даже чуть больший запас (на 42%)

320*96 = 30720 битов
VinKekFish позволяет брать себя с удлиняющими коэффициентами, в том числе, K = 3 и K = 5.
Кроме этого, VinKekFish K = 1 может впитать ключ размера 16384 битов за один шаг. Учитывая запас 2 на уязвимость в ключе, это значит, что потребная стойкость 30720/2=15360.

Хотя в схеме VinKekFish максимальная оценка стойкости выше 8192 битов, это дополнительный запас на то, что схема любительская, а также кое-какие ещё запасы на сложность криптоанализа и внутренние коллизии.
4096 битов вывода получаются довольно удобными в плане того, что это не очень много байтов вывода (16% от всех байтов): это затрудняет криптоанализ вывода по сравнению с 8192 битами. Кроме этого, если по ПЭМИН получают 1/2 от имеющейся энтропии, то запас в 2 раза может это компенсировать (а может и нет, ведь энтропию могут получать слишком много раз за непродолжительный промежуток времени).

Для экстремального перевода лет в биты имеем 560*96=53760. VinKekFish удовлетворит это с K = 15 (61440), а с учётом поглощения двойного ключа (то есть запас на некачественный ключ уже выработан) достаточно K = 9 (36864)
