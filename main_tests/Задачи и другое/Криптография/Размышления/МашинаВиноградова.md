# Машина сумасшедшего профессора (машина Виноградова)
"Машина сумасшедшего профессора" умеет решать любые уравнения с числами, длиной не более чем n-битов (длина числа определяется по длине сравниваемых чисел).
Требуется только лишь память на вход и на выход. n битов (вибитов) памяти означает, что она вводит в себя не более 2^n блоков информации и выводит из себя не более 2^n блоков информации (блок информации не более, чем n битов; то есть на вход и выход принимает/выдаёт не более n*2^n битов, если они не сформированны по блокам).
Из блока данных для некоторой n-битной функции "машина сумасшедшего профессора" всегда распознаёт этот блок за n-битную сложность (как один блок этого алгоритма). Для заданной стойкости n*k битов: n-битная функция может выдать не более ⎣n/k⎦ битов за блок (округление вниз).

Комментарий:
Длина числа в уравнении считается по длине сравниваемых чисел, а не по длине чисел, которые вводятся в функции. То есть для F64(b1024) = number64, где b1024 - это 1024 битное число, а F64 и number64 - это 64-битные функция и число, машина будет 64-битной.

Для DES машина будет принимать на вход только 56 битный неизвестный ключ и вычислять 64 битные блоки. То есть стойкость алгоритма здесь меньше, чем битность машины, если брать полный блок. Для этого, формально, можно просто обрезать блок до 56-ти битов.

Также машина может решить систему из n однобитных уравнений, где уравнения уже невозможно разделить на независимые части (или нехочется их делить). То есть сумма битностей уравнений в системе уравнений также может считаться битностью машины.

Такая машина может решать практически всё. Поэтому, стойкость алгоритма определяется количеством тактов машины и её необходимой битностью.


ПОСМОТРЕТЬ НА ТО, МОЖЕТ ЛИ КВАНТОВЫЙ КОМПЬЮТЕР ОБОГНАТЬ МАШИНУ 

## Пример AES+AES
Например, уравнение AES(k1, ctr1) + AES(k2, ctr1) + b1 = c1
ctr1 - известен (это счётчик)
b1 - известен, это открытый текст (атака с заданным текстом)
с1 - известен, это блок шифротекста
k1, k2 - неизвестны, блоки ключей
Приходим к уравнению F1(k1) + F2(k2) = c1
128+128 бит неизвестных. c1 - 128 битов известной информации.
Из них "машина сумасшедшего профессора" за один такт способна извлечь 128 битов (2^128) пар (k1, k2).
Следовательно, ей нужно 129 битов памяти (1 бит на хранение пары блоков и 128 битов на хранение 2^128 пар).
Далее, она вносит эти пары во второе уравнение F3(k1) + F4(k2) = c2 (взятое со второго блока шифрования).
Здесь из 128-ми битов неопределённости машина получает полную определённость, так как c2 вносит именно 128-мь битов определённости.
Следовательно, "машина сумасшедшего профессора" рассмотренный алгоритм решает за 129 битов сложности и 2 такта.


## Пример: дерево функций

### 512-битная машина
Две функции хеширования дают значения на вход третьей функции хеширования. Каждая функция инициализированна ключом полной длины с разными (но известными противнику) синхропосылками.
На каждом такте функция хеширует сама себя и даёт на выход своё значение.
Блок на выходе (когда получаем c1) обрезается до 256-ти битов.

c1 = trunc256 Hash0(k | Hash1(k) | Hash2(k)) (| - конкатенация)
c2 = trunc256 Hash0( k | Hash0(k | Hash1(k) | Hash2(k)) | Hash1(k | Hash1(k)) | Hash2(k | Hash2(k))  )

Числа k по 1024 бита. Блок хеширования по 512-ть битов. Блок на выходе (когда получаем c1) обрезается до 256-ти битов.

Начинаем решать первое уравнение.
256-ть битов на входе (c1). k одно и то же: 1024 бита. То есть неизвестны 1024 бита.
Берём 512-ти битную машину.
Попробуем поработать с хешами по 512-битов.

k11 = Hash1(k); k21 = Hash2(k)
k01 = Hash0(k) (берём упрощение, что можно записать так, как будет ниже записано)
c1 = trunc256 Hash0(k01 | k11 | k21)

Получаем три числа по 512 битов. Всего 1536 битов. Это то, что нам неизвестно.
То, что нам известно: с1 - 256 битов.
Неопределённость будет 1536−256=1280.
В данном случае мы не имеем парадокса дней рождения, так что учтём все эти 1280 битов.
Это означает, что наша машина уже должна быть 1280 битной.


Попробуем работать с ключом непосредственно.
c1 = trunc256 Hash0(k | Hash1(k) | Hash2(k))
Тогда, из уравнения берём 256 битов определённости и 1024 бита неопределённости. Так как битность у нас определяется сравниваемыми числами
Всего 1024-256=768 битов неопределённости.

512-битной машины недостаточно.


### 768-битная машина
Рассмотрим машину на 768 битов.
c1 = trunc256 Hash0(k | Hash1(k) | Hash2(k))
c2 = trunc256 Hash0( k | Hash0(k | Hash1(k) | Hash2(k)), Hash1(k | Hash1(k)), Hash2(k | Hash2(k))  )
c3 = trunc256 Hash0( ...  )

Битность машины определяется по сумме битов, а именно 256 (от c1), 256 (от c2) и 256 (от c3), всего 768.

Всего 768 бита известной информации и 1024 бита неизвестной информации. Таким образом, из этих уравнений мы сможем определить за один такт 768 битов информации, оставив 1024-768=256 бита информации.
Если мы повысим длину ключа до 768*2=1536 битов, то мы получим стойкость 768 битов.

Следовательно, стойкость такого алгоритма (по данному методу) 768-мь битов при длине ключа 1536 битов.


### Одиночная функция хеширования в гамме
Рассмотрим гамму, полученную простым хешированием
c1 = trunc256 Hash0(k | 0)
c2 = trunc256 Hash0(k | 1)
c3 = trunc256 Hash0(k | 2)
и т.п.

Стойкость алгоритма, определяемая по машине, здесь будет такой же, как и выше.
Вход от трёх блоков - 768 битов.
Ключ 1536 битов.
Получаем 1536-768=768 битов неопределённости.

Комментарий:
К сожалению, мы видим, что здесь само шифрование, формально, может быть любой стойкости.
В реальности ключ k, фактически, будет обрезан до длины общего состояния алгоритма. То есть мы не сможем его полностью сохранить в нашей функции. А значит, реально при внутреннем состоянии в 1024 бита ключ шифрования не может быть более 1024 битов стойкости, даже если мы введём более длинный ключ шифрования. Фактически, вместо ключа k мы можем взять уже готовый Hash0(k) и искать только его.
Таким образом, здесь эффективная длина ключа не более 1024 (при общем состоянии хеш-функции в 1024-ре бита). Достаточно 512-битной машины для расшифровки.


Пример выше, с иерархическими функциями, не может быть просто сведён к обрезанию ключа до внутреннего состояния. Так как Hash0, Hash1 и Hash2 - это функции с разными синхропосылками. Поэтому, один ключ там даст разные состояния и их придётся находить все. То есть эффективная длина ключа может быть большей.
Криптографические состояния функций хещирования криптографически завязаны на стойкость функции хеширования, что, скорее всего, также может служить поводом для атаки с этой машиной.

При этом, машина не видит разницы между, например, Hash(k | Hash(k)) и Hash(Hash(k) | k). Хотя, вообще говоря, это совершенно разные вещи (в одном случае можно предвычислить значение Hash(k), а в другом функция стартует каждый раз с новых значений и Hash(? | k) будет каждый раз разный, т.к. функция уже будет проинициализированна другим значением, а значит, больше энтропии будет получено из исходного k).



## Пример: 3DES

### 64-х битная машина
c1 = DES(k1, DES(k2, DES(k3, ctr)))

ctr - известен (счётчик).
с1 - 64 бита.
ключи k1, k2, k3 по 56-ть битов.

Неопределённость первого уравнения (если есть только один блок) 56*3=168 битов.
c1 - 64 бита определённости.
168-64=104

Получаем 104 бита неопределённости как стойкость алгоритма (в реальности атака встречи по середине даёт большую стойкость - 112 битов).

### 84-х битная машина
Попробуем взять машину, размером в 84-ре бита. Для этого из c2 (второго блока гаммы) возьмём нехватающие биты. Полученное число обозначим как cs1.
Конкатенирующую два блока функцию обозначим, для простоты, "cat20".

cs1 = DES(k1, DES(k2, DES(k3, ctr1))) cat20 DES(k1, DES(k2, DES(k3, ctr2)))

У нас 84-ть битов определённости. 168 битов неопределённости.
168-84=84.

Получаем 84 бита неопределённости.
Таким образом, нам достаточно 84-х битной машины, чтобы расшифровать 3DES.
