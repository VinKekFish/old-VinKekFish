// Версия файла 2021.05.06

Анализ всегда начинается с более низких классов (которые не используют других классов, подлежащих проверке)

0. Копирование проверяемых проектов
0.0. Копирование
	0. Создать директорию для копирования, аналогично 20210505 (дата копирования)
	1. Написать сопроводительный файл "-.txt" (в корне основной директории), что именно будет проверятся (перечень файлов указывается в файле "+.txt" в поддиректориях). Скопировать туда файлы "Проверки.txt" и "АлгоритмыПроверки.txt" и указать в них, что это - копии, и какого именно числа они скопированны
0.1. Перед копированием, убедится, что создана документация на проект
	1. Задекларированны состояния объектов. Проверить по файлу "Память.txt" пункт 3
	2. Задекларирован ввод-вывод, см. файл "Конфи.txt"
0.2. Скопировать все данные в отдельную директорию "sources" (это - неизменяемые копии оригиналов).
0.2.1. Переименовать sln-файл из VinKekFish.sln в Review-VinKekFish.sln . Удалить pdf-файлы с документацией на криптографию (чтобы сэкономить место на диске)

1. Проверка на правильные состояния объектов и выход за пределы массива и т.п.
Если проверки уже проведены и не внесено существенных изменений, допускается опускать эти проверки.
Провести проверку по файлу "Память.txt". Скопировать файл в директорию и отмечать в нём проведённые проверки.

1.2. Скопировать все данные из sources в новую директорию
	1. Пометить в сопроводительном файле "-.txt", для чего создаётся новая директория (пункт 1.2 Алгоритмов проверки)

1.3. Выписать в отдельный файл в корень, что именно проверяется на этом этапе
	1. Состояния объектов. Верно ли они используются (в том числе, запись в удалённый объект)
	2. Выход за пределы границ объектов	
	3. Наличие лишних функций, которые не используются
	4. Правильная работа с копиями объектов (их верное обнуление и освобождение, в том числе)

2. Конфиденциальность, ввод-вывод
	1. Документация ввода-вывода
	2. Работа с разными уровнями конфиденциальности и их ввод-вывод
	3. Для тайминг-атак: отсутствие условий, зависящих от высоких уровней конфиденциальности.


3. Проверка алгоритмов, подлежащих описанию в псевдокоде
	2.0. Снова сделать копию всех исходников, пометить назначении копии в "-.txt". Скопировать файл "Алг.txt" в корень копии.
	2.1. Проверить, что нужные алгоритмы описаны в псевдокоде. В частности, описана вся криптография
	2.2. Проверить, что алгоритмы в коде программы и в псевдокоде совпадают.
		1. Совпадают имена параметров, если это нужно (хотя бы не вводят в заблуждение случайным совпадением имён)
		2. Константы описаны в документации и поименованы также и имеют те же значения
		3. Все переменные алгоритма есть в коде
		4. Все шаги алгоритма есть в коде
		5. Алгоритм в коде делает то же, что и алгоритм в псевдокоде
Какие данные должна изменять/не изменять/использовать/очищать/уничтожать функция (выписать отдельно и сверить: по памяти и логике, по псевдокоду и по коду)



Дописать насчёт доступа к файлу
		fW207hkbNPcr Доступ к файлу
			0. Не создан
			1. Перемещён
			2. Путь к файлу перемещён (изменена переменная окружения)
			3. Удалён из-вне
			4. Удалён
			5. Заблокирован (на чтение, запись, удаление, запись, кроме дозаписи, на все операции)


Удобство использования и документация для программиста-пользователя



при многопоточности нужно, чтобы если при lock (this) Monitor.Wait  есть проверка, то она была бы перед входом в Wait, внутри this. Иначе один поток может изменить проверяемое условие в момент ожидания lock(this), вызвать pulseAll, который не поймает Monitor.Wait, и вход в Monitor.Wait будет навсегда
(эта ошибка была в LightRandomGenerator)
if (GeneratedCount >= CountToGenerate) Monitor.Wait(this);


Проверка комментариев и их наличия. Инструкций по использованию.
Проверка понятности и идентифицированности места (локализованности ошибки) в сообщениях об ошибках

Небезопасные функции должны быть помечены в названии как Unsecure

Обязательно всё пройти в отладчике по шагово, просматривая изменения и контролируя все объекты
В идеале, пройти пошагово покрытие хотя бы по строкам кода и по классам эквивалентности.


Если в коде есть что-то типа
lock (sync)
lock (this)

то нужно проверить, что функции, которые вызывают только lock (sync) не должны вызываться в lock (this) по документации. То есть lock (this) ещё может не быть, но он появится при использовании этого кода.

Один из параметров по-умолчанию может быть некорректным при некоторых классах эквивалентности
