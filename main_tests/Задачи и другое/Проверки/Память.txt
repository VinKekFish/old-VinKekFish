Выписка из "АлгоритмыПроверки.txt"

В копии исходного кода писать "ФАЙЛ ДЛЯ АНАЛИЗА" и писать внутри в комментариях сам текст анализа. Если нужна ссылка на строку исходного кода, делать её по неизменяемой копии оригинала (в папке sources)
Можно анализировать из разных редакторов: исходники из VisualStudio, а проверку делать во внешнем редакторе. Пометки номеров строк делать по строкам неизменяемой копии в папке "sources"

Если есть желание, создать файл "+.txt" для записи результатов и найденных ошибок.

1. Исключено
2. Исключено

3. Проверка документации.
	0. Определить набор файлов для проверки. Проверить, что состояния объектов где-то документированы и ссылка на документацию указана в исходниках. На каждый проверяемый файл можно создать свою копию контрольного файла для проверки либо указывать проверки прямо в файле
	1. Обратить особое внимание на то, что у объектов есть состояния "не инициализирован", "очищен"  и "уничтожен"
		1.1. Желательно, чтобы эти состояния были в одной группе
		1.2. 
			1.2.1. Из состояния "уничтожен" не должно быть выходов
			1.2.2. "Уничтожен" должно быть конечным состоянием (декларировано как конечное).
			1.2.3. В это состояние можно попасть напрямую или опосредованно из любого другого состояния без проведения каких-либо операций, не соответствующих семантике очистки/уничтожения (пока код не проверяется, только описание состояний)
			1.2.4. По возможности, во время исполнения должна быть проверка того, что объект действительно подвергся уничтожению
		1.3. -
		1.4. В состоянии "не инициализирован" должно соответствовать семантике
	2. Обратить особое внимание на то, указан ли допустимый порядок использования объекта (в зависимости от его состояний; допустимые переходы) и рекомендованный порядок состояний. Они должны быть указаны как в документации по состояниям, так и в понятной программисту-пользователю документации
	3. Можно ли отличить, в каком состоянии находится объект?  (какие переменные на это указывают?)
	4. Проверить, понятно ли описано, как создавать, использовать и утилизировать объект для конченого программиста-пользователя
	5. Все ли методы объекта указаны в документации по состояниям?
		5.0. Все ли методы перечисленны?
		5.1. Есть ли у каждого метода все группы состояний? Соответствуют ли они семантике метода?
	6. Пригодные и непригодные состояния
		1. Можно ли (во время исполнения программы) понять, что объект находится в состоянии "Утилизирован" ("уничтожен")? Если нет, то объект должен быть, после утилизации, недоступен.
		2. Можно ли во время исполнения программы понять, что объект находится в нужном для основного использования состоянии?
	

4. Начать со входа в программу (или статического конструктора проверяемого класса).

Все объекты, которые инициализируются, в том числе, в статических конструкторах, проверить на верность инициализации и указать в начале программы, какие объекты в каком состоянии.

На каждую строчку инициализаторов и программы:
0. Состояния объектов
	0. В начале программы и каждого статического и обычного конструктора: в каком состоянии находятся сейчас проинициализированные статически объекты (у тех, у которых много состояний)
		В частности, указатель или ссылка на объект не нулевые? Не освобождены?
	1. В каком состоянии сейчас находятся используемые в данной строке объекты?
	2. Производится ли запись в объект (возможно, где-то внутри)? Если да, то разрешена ли эта запись?
	3. Производится ли чтение? Если да, то разрешено ли оно?
	4. Производятся ли другие операции с объектом? Разрешены ли они?
	5. Если производится копирование объекта или ссылки, то пометить, что объект имеет копии или копии ссылки
	6. Полное ли копирование производится? Всё ли верно?
	7. Непригодные состояния
		7.0. Все ли созданные объекты переходят в состояние "очищен" и "уничтожен"?
		7.1. Можно ли понять, что объекты находятся в непригодном состоянии (непроинициализирован, очищен, уничтожен)?
		7.2. Деструктор объекта
			0. Деструктор переводит объект в состояние "очищен" или "уничтожен" (с вызовом исключения)?
			1. Верен ли вызов деструктора, если объект уже "очищен" или "уничтожен"?
	8. Все ли созданные объекты проходят полный допустимый или рекомендуемый цикл состояний?
	9. На факт наличия состояния код должен проверять одну и ту же переменную
	10. Есть ли защита от использования метода в неверном состоянии? Документировано ли предупреждение, если нет
	11. Реализует ли метод те состояния, которые описаны в документации?
		1. Переводит ли он в нужное состояние программу из любого другого доступного состояния?
		2. Как он реагирует на вызов с недопустимым состоянием? Описано ли такое поведение в документации?
		3. Переменные, указанные в документации по состоянию, действительно изменяются так, как указано? (аналогично п. 14)
		4. Вызывает ли он другие методы только в допустимых состояниях?
	12. Что будет при повторном вызове рассматриваемого метода сразу после окончания этого вызова?
	13. При переходе в состояние "очищен" объект должен перезаписывать всю конфиденциальную информацию
	14. Переменные, указывающие на состояние
		14.0. Переменные, указанные в документации по состоянию, действительно изменяются так, как указано?
		14.1. Для одного и того же состояния по всей программе используется одна и та же переменная?

1. Выход за пределы объектов (если объект индексируемый)
	2.1. Каков размер объекта? (или допустимый диапазон индексов, если это не массив)
	2.2. Обеспечены ли значения индексов в нужном диапазоне?
	2.3. Если есть условия на ввод, описаны ли они в документации или как проверки в коде?

2. Пометить функции, как используемые
