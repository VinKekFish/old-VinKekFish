Выписка из "АлгоритмыПроверки.txt"

1.3. Выписать в отдельный файл в корень, что именно проверяется на этом этапе
	1. Состояния объектов. Верно ли они используются (в том числе, запись в удалённый объект)
	2. Выход за пределы границ объектов	
	3. Наличие лишних функций, которые не используются
	4. Правильная работа с копиями объектов (их верное обнуление и освобождение, в том числе)


В копии исходного кода писать "Файл для анализа" и писать внутри в комментариях сам текст анализа. Если нужна ссылка на строку исходного кода, делать её по неизменяемой копии оригинала (в папке sources)

Создать файл "+.txt" для записи результатов и найденных ошибок


1. Проверить наличие документации по вводу-выводу:
	сеть
	диск
	межпроцессные взаимодействия, в том числе, именованные мьютексы, как функции, через которые могут проводиться тайминг-атаки, пайпы, общие участки памяти и т.п.
	неименованные примитивы синхронизаци, которые смотрят наружу и могут быть использованы для тайминг-атак (синхронизация) через вышестоящие примитивы
	запись в статические глобальные объекты (синглтоны), чтение/запись во внешние для класса глобальные (статические) переменные

2. Исключено

3. Проверить, что состояния объектов где-то документированы и ссылка на документацию указана в исходниках
	1. Обратить особое внимание на то, что у объектов есть состояния "не инициализирован", "очищен"  и "уничтожен"
		1.1. Желательно, чтобы эти состояния были в одной группе
		1.2. Из состояния "уничтожен" не должно быть выходов
		1.3. При переходе в состояние "очищен" объект должен перезаписывать всю конфиденциальную информацию
		1.4. В состоянии "не инициализирован" должно соответствовать семантике
	2. Обратить особое внимание на то, указан ли допустимый порядок использования объекта и рекомендованный порядок состояний.
	3. Обратить внимание на то, что выбраны переменные, по которым можно понять, в каком состоянии находится код (если это нужно). И если такие переменные есть, то для одного и того же состояния по всей программе используется одна и та же переменная

4. Начать со входа в программу (или статического конструктора проверяемого класса).

Все объекты, которые инициализируются, в том числе, в статических конструкторах, проверить на верность инициализации и указать в начале программы, какие объекты в каком состоянии.

На каждую строчку инициализаторов и программы:
0. Состояния объектов
	0. В начале программы и каждого статического и обычного конструктора: в каком состоянии находятся сейчас проинициализированные статически объекты (у тех, у которых много состояний)
		В частности, указатель или ссылка на объект не нулевые? Не освобождены?
	1. В каком состоянии сейчас находятся используемые в данной строке объекты?
	2. Производится ли запись в объект (возможно, где-то внутри)? Если да, то разрешена ли эта запись?
	3. Производится ли чтение? Если да, то разрешено ли оно?
	4. Производятся ли другие операции с объектом? Разрешены ли они?
	5. Если производится копирование объекта или ссылки, то пометить, что объект имеет копии или копии ссылки
	6. Полное ли копирование производится? Всё ли верно?
	7. Все ли созданные объекты переходят в состояние "очищены"?
	8. Все ли созданные объекты проходят полный допустимый или рекомендуемый цикл состояний?
	9. На факт наличия состояния код должен проверять одну и ту же переменную
	10. Есть ли защита от использования метода в неверном состоянии? Документировано ли предупреждение, если нет
1. Выход за пределы объектов (если объект индексируемый)
	2.1. Каков размер объекта? (или допустимый диапазон индексов, если это не массив)
	2.2. Обеспечены ли значения индексов в нужном диапазоне?
	2.3. Если есть условия на ввод, описаны ли они в документации или как проверки в коде?
2. Пометить функции, как используемые
